<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title>ThreeJS Model</title>

        <script src="js/THREEx.WindowResize.js"></script>
        <script src="js/THREEx.FullScreen.js"></script>


        <script type="module">

        // Find the latest version by visiting https://unpkg.com/three. The URL will
        // redirect to the newest stable release.
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        import {OrbitControls} from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';
        import {GLTFLoader} from 'https://unpkg.com/three/examples/jsm/loaders/GLTFLoader.js';

        //GLOBAL VARIABLE

        //SCENE
        const scene = new THREE.Scene();

        // CAMERA
        const viewAngle = 75;
        const windowW = window.innerWidth;
        const windowH = window.innerHeight;
        const aspectRatio = windowW/windowH;
        const near = 10;
        const far = 1000;

        const camera = new THREE.PerspectiveCamera(viewAngle, aspectRatio, near, far);
        // camera.position.z = 30; // back out of screen from origin (0,0,0)
        camera.position.set(-50,50, -100); // x,y,z
        
        // RENDERER
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(windowW, windowH);
        document.body.appendChild(renderer.domElement);


        // COLORED background - replace HEXCODDE with any hex color
        renderer.setClearColor( 0xf0e7cc ); 

        //SHOW AXES FOR REF. for POSITIONING
        const axesHelper = new THREE.AxesHelper( 200 );
        scene.add( axesHelper );

        // EVENTS
        THREEx.WindowResize(renderer, camera);
        THREEx.FullScreen.bindKey({charCode : "m".charCodeAt()});

        // LAMP MODEL
        const lamp = new GLTFLoader();
        lamp.load("lamp/scene.gltf", gltf=>{
            gltf.scene.scale.multiplyScalar(100);
            gltf.scene.position.x = 10;
            gltf.scene.position.z = 8;
            gltf.scene.position.y = 15;
        	scene.add( gltf.scene );
        }, undefined, error=>{
            console.error(error);
        });

        //ROCK MODEL
        const rock = new GLTFLoader();
        rock.load("rock/scene.gltf", gltf=>{
            // adjust scalar factor to match your scene scale
            gltf.scene.scale.multiplyScalar(1 / 2);
            //gltf.scene.rotation.z = 180;
        	scene.add( gltf.scene );
        }, undefined, error=>{
            console.error(error);
        });


        //LIGHTS
        const light2 = new THREE.PointLight(0xffffff);
        light2.position.set(100,100,100);
        scene.add(light2);

        // Load Light
        const ambientLight = new THREE.AmbientLight( 0x52514f );
        scene.add( ambientLight );

        // CONTROLS
        //const controls = new OrbitControls(camera, renderer.domElement);


        //ADD RAYCASTER AND MOUSE ELEMENT AS 2D VECTOR (X,Y)point.
        var raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        //2nd event listener is for mobile touch screens
        //document.addEventListener ('touchstart',onDocumentTouchStart, false);

        //MouseDown function to get clientside X,Y value to pass to raycaster and mouse.
        function onDocumentMouseDown (event){
            //cancel default method
            event.preventDefault();

            //set x,y vales based on raycasted values of mouse
            mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
            mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

            console.log(mouse);

            //ternary operator  or if statement to say if light is in scene, then remove if not add to scene.... or smth similar.... weeeeee
            scene.remove(light2);

        }


        function render() {
            camera.lookAt(scene.position);
            raycaster.setFromCamera (mouse, camera);

            const intersects = raycaster.intersectObjects (scene.children);
            
            for (let i=0; i<intersects.length; i++) {
                intersects[i].object.material.color.set(0xfff000);
            }
            
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }
        render();

        //addEventListener for mouse. calls function on DOcumentMouseDown when activated.
        window.addEventListener('mousedown', onDocumentMouseDown, false);
        

        </script>
		<meta name="viewport" content="width=device-width, user-scalable=no" />
		<style>
		body {margin:0px;}
		canvas {width:100%; height:100%;}
		</style>

    </head>
    <body>

    </body>
</html>
