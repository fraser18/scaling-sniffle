<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head>
        <meta charset="utf-8">
        <title>ThreeJS Model</title>

        <script src="js/THREEx.WindowResize.js"></script>
        <script src="js/THREEx.FullScreen.js"></script>


        <script type="module">

        // Find the latest version by visiting https://unpkg.com/three. The URL will
        // redirect to the newest stable release.
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        import {OrbitControls} from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';
        import {GLTFLoader} from 'https://unpkg.com/three/examples/jsm/loaders/GLTFLoader.js';
        import { Refractor } from 'https://unpkg.com/three/examples/jsm/objects/Refractor.js';
        import { WaterRefractionShader } from 'https://unpkg.com/three/examples/jsm/shaders/WaterRefractionShader.js';
        

        //GLOBAL VARIABLE
        let scene, camera, clock, renderer, refractor;

        //SCENE
        scene = new THREE.Scene();

        // clock
        clock = new THREE.Clock();

        // CAMERA
        const viewAngle = 45;
        const windowW = window.innerWidth;
        const windowH = window.innerHeight;
        const aspectRatio = windowW/windowH;
        const near = 10;
        const far = 1000;

        camera = new THREE.PerspectiveCamera(viewAngle, aspectRatio, near, far);
        // camera.position.z = 30; // back out of screen from origin (0,0,0)
        //camera.position.set(0,100,0); // x,y,z
        camera.position.set(100, 100, -80);

        
        // RENDERER
        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(windowW, windowH);
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

        
        // COLORED background - replace HEXCODDE with any hex color
        renderer.setClearColor( 0x101d30 ); 

        //SHOW AXES FOR REF. for POSITIONING
        const axesHelper = new THREE.AxesHelper( 200 );
        scene.add( axesHelper );

        // EVENTS
        THREEx.WindowResize(renderer, camera);
        THREEx.FullScreen.bindKey({charCode : "m".charCodeAt()});

        //WATER MESH
        const refractorGeometry = new THREE.PlaneGeometry( 1000 , 1000 );

        refractor = new Refractor (refractorGeometry, {
            color:0x999999,
            textureWidth: 1024,
            textureHeight:1024,
            shader: WaterRefractionShader
        });
        
        refractor.position.set(0,5,0);
        refractor.rotation.x = -(Math.PI / 2);
        scene.add(refractor);

        const dudvMap = new THREE.TextureLoader().load( 'images/waterdudv.jpg', function() {
            animate();
        } );

        dudvMap.wrapS = dudvMap.wrapT = THREE.RepeatWrapping;
        refractor.material.uniforms["tDudv"].value = dudvMap;

        
        //DIRT GROUND texture & Material
        let groundTexture = new THREE.TextureLoader().load('images/pond.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;

        groundTexture.repeat.set(0.5,0.5);
        groundTexture.anistropy= 46;
        groundTexture.encoding = THREE.sRGBENcoding;

			var groundMaterial = new THREE.MeshStandardMaterial( { map: groundTexture } );

			var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 100, 100 ), groundMaterial );
			mesh.position.y = -5;
			mesh.rotation.x = - Math.PI / 2;
			mesh.receiveShadow = true;
			scene.add( mesh );


        // LAMP MODEL
        const lamp = new GLTFLoader();
        lamp.load("lamp/scene.gltf", gltf=>{
            gltf.scene.scale.multiplyScalar(100);
            gltf.scene.position.x = 10;
            gltf.scene.position.z = 8;
            gltf.scene.position.y = 15;
            gltf.scene.castShadow = true;
        	scene.add( gltf.scene );
        }, undefined, error=>{
            console.error(error);
        });

        //ROCK MODEL
        const rock = new GLTFLoader();
        rock.load("rock/scene.gltf", gltf=>{
            // adjust scalar factor to match your scene scale
            gltf.scene.scale.multiplyScalar(1 / 2);
            //gltf.scene.rotation.z = 180;
        	scene.add( gltf.scene );
        }, undefined, error=>{
            console.error(error);
        });

        //FROG MODEL
        const frog = new GLTFLoader();
        frog.load("frog/scene.gltf", gltf=>{
            // adjust scalar factor to match your scene scale
            gltf.scene.position.y = 20;
            gltf.scene.position.x = 4;
            gltf.scene.position.z = -3;
            gltf.scene.rotation.y = 90;
            gltf.scene.scale.multiplyScalar(3 / 4);
        	scene.add( gltf.scene );
        }, undefined, error=>{
            console.error(error);
        });
        frog.castShadow=true;

        //LIGHTS
        const light2 = new THREE.PointLight( 0xffffff );
        light2.position.set(100,100,100);
        scene.add(light2);

        // Load Light
        const ambientLight = new THREE.AmbientLight( 0x0d0f2b );
        scene.add( ambientLight );


        //SPOTLIGHT COMING FROM LAMP
        const spotLight = new THREE.SpotLight( {color:0xf5d740, intensity:0.25, angle: Math.PI/4} );
        spotLight.position.set(4, 45, 4);
        spotLight.castShadow = true;
        scene.add( spotLight );
        

        //const spotLightHelper = new THREE.SpotLightHelper( spotLight );
        //scene.add( spotLightHelper );

        // CONTROLS
        //const controls = new OrbitControls(camera, renderer.domElement);


        //ADD RAYCASTER AND MOUSE ELEMENT AS 2D VECTOR (X,Y)point.
        var raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        //2nd event listener is for mobile touch screens
        //document.addEventListener ('touchstart',onDocumentTouchStart, false);

        function onDocumentMouseDown (event){
            //cancel default method
            event.preventDefault();

            //set x,y vales based on raycasted values of mouse
            // mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
            // mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

            // console.log(mouse);

            //toggle light on and off
            if (spotLight.visible === true) {
                spotLight.visible=false;
            }else {
                spotLight.visible=true;
            }
            
        }

        //ANIMATE 
        function animate () {
            requestAnimationFrame(animate);
            render();
        }


        function render() {
            refractor.material.uniforms[ "time" ].value += clock.getDelta();

            camera.lookAt(scene.position);
            raycaster.setFromCamera (mouse, camera);

            const intersects = raycaster.intersectObjects (scene.children);
            

            // all object in raycast to turn yellow
            // for (let i=0; i<intersects.length; i++) {
            //     intersects[i].object.material.color.set(0xfff000);
            // }
            
            renderer.render(scene, camera);
        }
        render();

        //addEventListener for mouse. calls function on DOcumentMouseDown when activated.
        window.addEventListener('mousedown', onDocumentMouseDown, false);
        

        </script>
		<meta name="viewport" content="width=device-width, user-scalable=no" />
		<style>
		body {margin:0px;}
		canvas {width:100%; height:100%;}
		</style>

    </head>
    <body>

    </body>
</html>
