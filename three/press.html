<html>
<head>
    <meta charset="utf-8">
    <title>ThreeJS Press</title>

    <script src="https://zimjs.org/cdn/1.3.2/createjs.js"></script>
    <script src="https://zimjs.org/cdn/cat/03/zim.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/THREEx.WindowResize.js"></script>
    <script src="js/THREEx.FullScreen.js"></script>
    <script src="js/KeyboardState.js"></script>

    <script>
        window.addEventListener("DOMContentLoaded", () => {

            // SCENE
            const scene = new THREE.Scene();

            // CAMERA
            const viewAngle = 70;
            const windowW = window.innerWidth;
            const windowH = window.innerHeight;
            const aspectRatio = windowW/windowH;
            const near = .1;
            const far = 1000;

            const camera = new THREE.PerspectiveCamera(viewAngle, aspectRatio, near, far);
            // camera.position.z = 30; // back out of screen from origin (0,0,0)
            camera.position.set(30,10,30); // x,y,z
            // camera.lookAt(scene.position);

            // RENDERER
            const renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setSize(windowW, windowH);
            console.log(renderer.domElement);
            document.body.appendChild(renderer.domElement);

            // EVENTS
            THREEx.WindowResize(renderer, camera);
        	THREEx.FullScreen.bindKey({charCode : "m".charCodeAt()});
            var keyboard = new KeyboardState();


            // GEOMETRY
            const geometry = new THREE.BoxGeometry(5, 5, 5);

            // MATERIAL
            // const material = new THREE.MeshBasicMaterial({color:0x333333}); // no shading
            // const material = new THREE.MeshLambertMaterial({color:0x666666}); // needs light
            // const material = new THREE.MeshPhongMaterial({color:0x666666}); // needs light and is glossy
            const material = new THREE.MeshNormalMaterial(); // test colors

            // MESH
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            // cube.scale.x = 2;

            // dot format for animate()
            // animate({
            //     target:cube,
            //     props:{"scale.x":3, "scale.y":3, "scale.z":3},
            //     time:2,
            //     ease:"elasticInOut",
            //     loop:true,
            //     rewind:true
            // });

            // rect.effect(new GlowEffect(red,10,10))
            // // rect.effects.glow.blurX = 30;
            // rect.animate({"effects.glow.blurX":50}, 5)


            // NEW
            // Example of RayCasting
            const mouse = {x:0, y:0};
            // let dir = 1;

            const raycaster = new THREE.Raycaster();
            renderer.domElement.addEventListener("mousedown", e => {

                console.log("mousedown");

                // convert the mouse to a ratio from the middle of the screen
                // -1,-1  +0,-1  +1,-1
                // -1,+0  +0,+0  +1,+0
                // -1,+1  +0,+1  +1,+1
                mouse.x = (e.clientX/window.innerWidth) * 2 - 1;
                mouse.y = - (e.clientY/window.innerHeight) * 2 + 1;

                // set the ray from camera to mouse
                raycaster.setFromCamera(mouse, camera);

                // get array of intersecting objects
                let intersects = raycaster.intersectObjects(scene.children);

                console.log(intersects);

                // can check the length if only one object
                // if more, then do test like remove() example below
                if (intersects.length > 0) {
                    animate({
                        target:cube,
                        props:{"scale.x":3, "scale.y":3, "scale.z":3},
                        time:2,
                        ease:"elasticOut",
                        // loop:true,
                        rewind:true
                    });
                }

                // intersects.forEach(intersect=>{
                //     if (intersect.object == cube) {
                //         // an example of removing the cube
                //         scene.remove(cube);
                //     }
                // });

                // for (var i=0; i<intersects.length; i++) {
                //     let intersect = intersects[i];
                //     // intersect has object, distance, face3, faceIndex, point, uv properties
                //     if (intersect.object == cube) {
                //
                //         // an example of removing the cube
                //         // scene.remove(cube);
                //
                //         // an example of scaling the cube
                //         // or you could animate it in a similar way
                //         // to how we spin the room
                //         cube.scale.x+=.1*dir;
                //         cube.scale.y+=.1*dir;
                //         cube.scale.z+=.1*dir;
                //         if (cube.scale.x > 2 || cube.scale.x < 1) {
                //             dir *= -1;
                //         }
                //         // if (cube.scale.x > 2) {
                //         //     // cube.scale.set(1,1,1); // or 2,2,2 to limit
                //         // }
                //
                //         // an example of changing the color
                //         // set the color of the side that was clicked on
                //         // the face is a triangle in the geometry
                //         // I could not get the triangle to change color
                //         // despite reading 2 different ways to do it
                //         // but I eventually got the material to change!
                //         // first get the material index of the face
                //         // then use that on the cubes material array
                //
                //         // this only works if the cube has an array of materials set
                //         let materialIndex = intersect.face.materialIndex; // sigh
                //         cube.material[materialIndex].color.setHex(0xffffff); // sigh
                //
                //         // this would work if the cube had just one material
                //         // rather than an array of materials
                //         // cube.material.color.setHex(0xffffff);
                //     }
                // }

            }); // end of mousedown




            // LIGHT
            const light = new THREE.PointLight(0x0000ff);
            light.position.set(100,200,100);
            scene.add(light);

            const light2 = new THREE.PointLight(0xffffff);
            light2.position.set(-100,-200,-100);
            scene.add(light2);

            const light3 = new THREE.AmbientLight(0xff0000);
            scene.add(light3);

            // CONTROLS
            const controls = new THREE.OrbitControls(camera, renderer.domElement);

            // ANIMATION
            function render() {

                if (keyboard.pressed("z")) {
            		console.log("z pressed");
            	}

                // cube.rotation.x += 0.005;
                // radians 5*Math.PI/180 // 5 degrees in radians
                cube.rotation.y += 0.005;
                // cube.rotation.z += 0.005;

                // camera.rotation.y += .005;

                renderer.render(scene, camera);

                requestAnimationFrame(render);
            }
            render();
        });
    </script>

    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    	body {margin:0px;}
    	canvas {width:100%; height:100%}
    </style>
</head>
<body>
</body>
</html>
